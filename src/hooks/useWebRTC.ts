import { useState, useEffect, useRef, useCallback } from 'react';
import { rtcConfiguration, mediaConstraints } from '@/lib/webrtcConfig';

// Define the structure for signaling messages (adapt to your Go server's format)
export interface SignalingMessage {
  type: 'offer' | 'answer' | 'candidate' | 'user-joined' | 'user-left' | 'join-room';
  payload: any; // sdp offer/answer object or ice candidate object
  targetPeerId?: string; // Required for direct messages (offer, answer, candidate)
  senderPeerId?: string; // ID of the user sending the message
  allUserIds?: string[]; // Optional: Sent on successful join for initial connection setup
}

// Define the structure for peer connections state
export interface PeerConnectionState {
  [peerId: string]: RTCPeerConnection;
}

// Define the structure for remote streams state
export interface RemoteStreamsState {
  [peerId: string]: MediaStream;
}

// --- Custom Hook ---

/**
 * Manages WebRTC connections, local media, and signaling interactions.
 * @param roomId The ID of the chat room.
 * @param signalingChannel An object or class instance responsible for sending/receiving signaling messages.
 *                         This needs methods like `send(message)` and an event listener setup (`onMessage(callback)`).
 *                         *You will need to implement this based on your WebSocket connection to the Go server.*
 */
export function useWebRTC(roomId: string | null, signalingChannel: any /* Replace 'any' with your SignalingChannel type/interface */) {
  const [localStream, setLocalStream] = useState<MediaStream | null>(null);
  const [remoteStreams, setRemoteStreams] = useState<RemoteStreamsState>({});
  const peerConnections = useRef<PeerConnectionState>({});
  const localStreamRef = useRef<MediaStream | null>(null); // Ref to ensure cleanup uses the correct stream instance
  const myPeerId = useRef<string | null>(null); // Store our own ID assigned by signaling server or generated client-side

  // --- Initialization ---

  /**
   * Initializes local media stream.
   * Returns true on success, false on failure.
   */
  const initializeMedia = useCallback(async (): Promise<boolean> => {
    try {
      console.log('Requesting media access...');
      const stream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
      console.log('Media access granted.');
      setLocalStream(stream);
      localStreamRef.current = stream; // Store in ref for cleanup
      // TODO: Set myPeerId.current here (e.g., from signaling server confirmation)
      return true;
    } catch (error) {
      console.log('Error accessing media devices.', error);
      // Handle permissions error (e.g., show message to user)
      return false;
    }
  }, []);

  // --- Peer Connection Management ---

  /**
   * Handles a user leaving the room (received via signaling).
   * Cleans up the connection and remote stream for that peer.
   * @param peerId The ID of the user who left.
   */
  const handlePeerLeaving = useCallback((peerId: string) => {
    console.log(`Peer ${peerId} is leaving or connection failed.`);

    // Close PeerConnection
    if (peerConnections.current[peerId]) {
      peerConnections.current[peerId].close();
      delete peerConnections.current[peerId];
      console.log(`Closed peer connection for ${peerId}`);
    } else {
        console.warn(`Attempted to clean up non-existent peer connection for ${peerId}`);
    }

    // Remove Remote Stream
    setRemoteStreams((prevStreams) => {
      const newStreams = { ...prevStreams };
      if (newStreams[peerId]) {
        // Optional: Stop tracks if necessary, though usually handled by browser when connection closes
        // newStreams[peerId].getTracks().forEach(track => track.stop());
        delete newStreams[peerId];
        console.log(`Removed remote stream for ${peerId}`);
      }
      return newStreams;
    });
  }, []);

  /**
   * Creates and configures an RTCPeerConnection instance for a given peer.
   * @param peerId The ID of the peer to connect to.
   */
  const createPeerConnection = useCallback((peerId: string) => {
    console.log(`Creating peer connection for ${peerId}`);
    if (peerConnections.current[peerId]) {
       console.warn(`Peer connection for ${peerId} already exists.`);
       return peerConnections.current[peerId];
    }

    const pc = new RTCPeerConnection(rtcConfiguration);

    // Handle ICE candidates generated by the local PeerConnection
    pc.onicecandidate = (event) => {
      if (event.candidate && signalingChannel && myPeerId.current) {
        console.log(`Sending ICE candidate to ${peerId}`);
        const message: SignalingMessage = {
          type: 'candidate',
          payload: event.candidate,
          targetPeerId: peerId,
          senderPeerId: myPeerId.current,
        };
        // **ACTION**: Send message via your signaling channel (WebSocket)
        signalingChannel.send(message);
      }
    };

    // Handle incoming remote tracks
    pc.ontrack = (event) => {
      console.log(`[ontrack EVENT] Received track event for peer: ${peerId}`, event);
      if (event.streams && event.streams[0]) {
        const stream = event.streams[0];
        console.log(`[ontrack] Stream found: ${stream.id}. Will update state for ${peerId}.`);
        setRemoteStreams((prevStreams) => {
          console.log(`[ontrack setRemoteStreams] Updating for ${peerId}. Prev keys: [${Object.keys(prevStreams).join(', ')}]`);
          // Check if stream is already added to prevent potential re-renders/loops
          if (prevStreams[peerId]?.id === stream.id) {
            console.log(`[ontrack setRemoteStreams] Stream ${stream.id} already exists for ${peerId}. Skipping update.`);
            return prevStreams;
          }
          const newState = {
            ...prevStreams,
            [peerId]: stream,
          };
          console.log(`[ontrack setRemoteStreams] Added stream ${stream.id} for ${peerId}. New keys: [${Object.keys(newState).join(', ')}]`);
          return newState;
        });
      } else {
         // Log if the stream isn't available on the event as expected
         console.warn(`[ontrack] Received track event for ${peerId}, BUT event.streams[0] is missing.`);
         // Removed fallback logic - rely solely on event.streams[0]
      }
    };

    // Add local tracks to the connection
    console.log(`[createPeerConnection ${peerId}] Checking localStreamRef.current:`, localStreamRef.current);
    if (localStreamRef.current) {
      localStreamRef.current.getTracks().forEach((track) => {
        console.log(`[createPeerConnection ${peerId}] Adding local ${track.kind} track: ${track.id}`);
        pc.addTrack(track, localStreamRef.current!);
      });
    } else {
        console.warn(`[createPeerConnection ${peerId}] Local stream NOT available when creating connection.`);
    }

    // Handle connection state changes (optional but good for debugging/UI)
    pc.onconnectionstatechange = () => {
        console.log(`Connection state with ${peerId}: ${pc.connectionState}`);
        if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected' || pc.connectionState === 'closed') {
            // Handle peer disconnection cleanup if needed
             handlePeerLeaving(peerId);
        }
    };

    pc.oniceconnectionstatechange = () => {
        console.log(`ICE connection state with ${peerId}: ${pc.iceConnectionState}`);
    }

    peerConnections.current[peerId] = pc;
    return pc;
  }, [signalingChannel, handlePeerLeaving, localStreamRef, myPeerId]);

  /**
   * Initiates a connection to a peer by creating an offer.
   * @param peerId The ID of the peer to connect to.
   */
  const initiatePeerConnection = useCallback(async (peerId: string) => {
       if (!myPeerId.current) {
           console.log("Cannot initiate connection: My peer ID is not set.");
           return;
       }
       if (peerConnections.current[peerId]) {
           console.log(`Connection attempt already in progress or exists for ${peerId}`);
           return; // Avoid race conditions / redundant offers
       }

       const pc = createPeerConnection(peerId);
        try {
           console.log(`Creating offer for ${peerId}`);
           const offer = await pc.createOffer();
           await pc.setLocalDescription(offer);

           console.log(`Sending offer to ${peerId}`);
           const message: SignalingMessage = {
               type: 'offer',
               payload: offer,
               targetPeerId: peerId,
               senderPeerId: myPeerId.current,
           };
            // **ACTION**: Send message via your signaling channel (WebSocket)
            if (signalingChannel) {
               signalingChannel.send(message);
            }
       } catch (error) {
           console.log(`Error creating offer for ${peerId}:`, error);
       }
  }, [createPeerConnection, signalingChannel, myPeerId]);

  // --- Signaling Message Handlers ---

  /**
   * Handles an incoming SDP offer from a peer.
   * Creates an answer and sends it back.
   * @param peerId The ID of the peer who sent the offer.
   * @param offer The SDP offer object.
   */
  const handleOffer = useCallback(async (peerId: string, offer: RTCSessionDescriptionInit) => {
    console.log(`Received offer from ${peerId}`);
    if (!myPeerId.current) {
        console.log("Cannot handle offer: My peer ID is not set.");
        return;
    }

    const pc = createPeerConnection(peerId);
    try {
        await pc.setRemoteDescription(new RTCSessionDescription(offer));
        console.log(`Creating answer for ${peerId}`);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        console.log(`[SDP handleOffer] Offer set as remote, Answer set as local for ${peerId}.`);
        console.log(`  Remote Description (Offer from ${peerId}):`, pc.remoteDescription?.sdp);
        console.log(`  Local Description (My Answer to ${peerId}):`, pc.localDescription?.sdp);

        console.log(`Sending answer to ${peerId}`);
        const message: SignalingMessage = {
            type: 'answer',
            payload: answer,
            targetPeerId: peerId,
            senderPeerId: myPeerId.current,
        };
         // **ACTION**: Send message via your signaling channel (WebSocket)
        if (signalingChannel) {
            signalingChannel.send(message);
        }
    } catch (error) {
        console.log(`Error handling offer from ${peerId}:`, error);
    }
  }, [createPeerConnection, signalingChannel, myPeerId]);

  /**
   * Handles an incoming SDP answer from a peer.
   * Sets the remote description on the corresponding PeerConnection.
   * @param peerId The ID of the peer who sent the answer.
   * @param answer The SDP answer object.
   */
  const handleAnswer = useCallback(async (peerId: string, answer: RTCSessionDescriptionInit) => {
    console.log(`[handleAnswer] Received answer from ${peerId}:`, answer);
    const pc = peerConnections.current[peerId];
    if (pc && pc.signalingState !== 'stable') { // Only set answer if we are expecting one
      try {
        console.log(`[handleAnswer] Attempting pc.setRemoteDescription for ${peerId}`);
        await pc.setRemoteDescription(new RTCSessionDescription(answer));
        console.log(`[handleAnswer] pc.setRemoteDescription successful for ${peerId}`);
        console.log(`[SDP handleAnswer] Answer from ${peerId} set as remote.`);
        console.log(`  Local Description (My Offer to ${peerId}):`, pc.localDescription?.sdp);
        console.log(`  Remote Description (Answer from ${peerId}):`, pc.remoteDescription?.sdp);
      } catch (error) {
        console.error(`[handleAnswer] Error in pc.setRemoteDescription for ${peerId}:`, error);
      }
    } else {
        console.warn(`[handleAnswer] Received answer from ${peerId}, but no connection found or state is stable (${pc?.signalingState}). Ignoring.`);
    }
  }, []);

  /**
   * Handles an incoming ICE candidate from a peer.
   * Adds the candidate to the corresponding PeerConnection.
   * @param peerId The ID of the peer who sent the candidate.
   * @param candidate The ICE candidate object.
   */
  const handleIceCandidate = useCallback(async (peerId: string, candidate: RTCIceCandidateInit) => {
    // console.log(`Received ICE candidate from ${peerId}`); // Can be very verbose
    console.log(`[handleIceCandidate] Received candidate from ${peerId}:`, candidate);
    const pc = peerConnections.current[peerId];
    if (pc) {
      try {
        // Ensure candidate object is valid before adding
        if (candidate && candidate.candidate) {
             console.log(`[handleIceCandidate] Attempting pc.addIceCandidate for ${peerId}`);
             await pc.addIceCandidate(new RTCIceCandidate(candidate));
             // console.log(`Added ICE candidate from ${peerId}`); // Verbose
             console.log(`[handleIceCandidate] pc.addIceCandidate successful for ${peerId}`);
        } else {
          console.warn(`[handleIceCandidate] Received invalid/empty candidate from ${peerId}. Ignoring.`);
        }
      } catch (error) {
        // Don't log candidate errors unless ICE gathering state is 'complete'
        // This avoids logging expected errors during trickle ICE negotiation.
        if (pc.iceGatheringState === 'complete') {
            console.error(`[handleIceCandidate] Error adding ICE candidate from ${peerId} after gathering complete:`, error);
        } else {
             console.warn(`[handleIceCandidate] Error adding ICE candidate from ${peerId} (state: ${pc.iceGatheringState}):`, error);
        }
      }
    } else {
        console.warn(`[handleIceCandidate] Received ICE candidate from ${peerId}, but no peer connection found. Ignoring.`);
    }
  }, []);

  /**
   * Handles a new user joining the room (received via signaling).
   * Initiates connections to all existing users.
   * @param newPeerId The ID of the user who just joined.
   * @param allUserIds List of all user IDs currently in the room (including the new one).
   */
   const handleUserJoined = useCallback((newPeerId: string, allUserIds: string[]) => {
        console.log(`User ${newPeerId} joined. All users:`, allUserIds);
        if (!myPeerId.current || newPeerId === myPeerId.current) {
            // Don't connect to self or if own ID isn't set yet
            if (!myPeerId.current) console.warn("Cannot initiate connections: My peer ID is not set.");
            return;
        }

        // If I am the new user, connect to everyone already there
        if (newPeerId === myPeerId.current) {
            console.log("I am the new user. Existing peers will initiate connection.");
             // No longer initiating connections from the new peer side
        } else {
             // An existing user receives notification about the new user
             console.log(`Initiating connection to new user ${newPeerId}`);
             initiatePeerConnection(newPeerId); // Keep this: Existing peer initiates
        }

   }, [initiatePeerConnection, myPeerId]);

  // --- Effects ---

  // Effect to set up signaling message listener
  useEffect(() => {
    if (!signalingChannel) {
        console.log("Signaling channel not yet available.");
        return;
    }
    console.log("Setting up signaling message listener.");

    const messageHandler = (message: SignalingMessage) => {
      console.log('Received signaling message:', message);

      // Ensure senderPeerId is present for messages originating from others
      if (!message.senderPeerId && message.type !== 'user-joined') { // user-joined might be a broadcast
         console.warn("Received message without senderPeerId:", message);
         // return; // Decide if you want to ignore such messages
      }
       const peerId = message.senderPeerId!; // Assume senderPeerId is valid based on your server logic

      switch (message.type) {
        case 'offer':
          handleOffer(peerId, message.payload);
          break;
        case 'answer':
          console.log(`[messageHandler] Received 'answer' from ${peerId}`);
          handleAnswer(peerId, message.payload);
          break;
        case 'candidate':
          // Avoid logging every candidate in the main handler, handleIceCandidate logs enough
          // console.log(`[messageHandler] Received 'candidate' from ${peerId}`); // <-- COMMENTED OUT TO REDUCE NOISE
          handleIceCandidate(peerId, message.payload);
          break;
        case 'user-joined':
           // Assuming payload contains { newPeerId: string, allUserIds: string[] }
           // You might need to adjust this based on your Go server implementation
           const { newPeerId, allUserIds } = message.payload;
           if(newPeerId && allUserIds){
               // Set own ID if this is the confirmation after joining
               if(!myPeerId.current){
                   myPeerId.current = newPeerId; // Assign ID based on signaling server ack
                   console.log("My Peer ID set to:", myPeerId.current);
               }
               handleUserJoined(newPeerId, allUserIds);
           } else {
               console.warn("Received 'user-joined' message with missing payload details.");
           }
           break;
        case 'user-left':
           // Assuming payload contains { peerId: string }
           const leavingPeerId = message.payload?.peerId || peerId; // Use payload if available, otherwise assume sender left
           if (leavingPeerId) {
             handlePeerLeaving(leavingPeerId);
           } else {
               console.warn("Received 'user-left' message without a peerId.");
           }
           break;
        default:
          console.warn('Received unknown signaling message type:', message.type);
      }
    };

    // Replace with your actual signaling channel subscription method
    signalingChannel.onMessage(messageHandler);

    // **ACTION**: Join the room via signaling - this might trigger the 'user-joined' broadcast
    // signalingChannel.send({ type: 'join-room', payload: { roomId } });

    // Cleanup function
    return () => {
      console.log("Removing signaling message listener.");
      // **ACTION**: Unsubscribe from your signaling channel
      // signalingChannel.offMessage(messageHandler); // Example cleanup
    };
  }, [signalingChannel, roomId, localStream, handleOffer, handleAnswer, handleIceCandidate, handleUserJoined, handlePeerLeaving]);

  // Effect for cleanup on component unmount or room change
  useEffect(() => {
    // This function will run when the component unmounts or dependencies change
    return () => {
      console.log('Cleaning up WebRTC hook...');

      // Stop local media tracks
      if (localStreamRef.current) {
        console.log('Stopping local media stream tracks.');
        localStreamRef.current.getTracks().forEach((track) => track.stop());
        localStreamRef.current = null; // Clear ref
        setLocalStream(null); // Clear state
      }

      // Close all peer connections
      console.log('Closing all peer connections.');
      Object.values(peerConnections.current).forEach((pc) => pc.close());
      peerConnections.current = {}; // Clear the connections ref

      // Clear remote streams state
      setRemoteStreams({});
      console.log("INFO: remoteStreams cleared");

      // TODO: Disconnect from signaling server if necessary
       if (signalingChannel) {
           console.log("Disconnecting signaling channel (example).");
           // signalingChannel.disconnect(); // Example
       }
       myPeerId.current = null; // Reset peer ID
    };
  }, [signalingChannel, roomId]); // Re-run cleanup if signaling or room changes


  // --- Return values ---
  return {
    localStream,
    remoteStreams,
    initializeMedia,
    // You might expose other functions if needed for specific UI interactions (e.g., toggle mic/video)
  };
} 